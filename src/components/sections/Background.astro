---
// src/components/Background3D.astro
---

<div id="canvas-container"></div>

<style lang="scss">
  #canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    z-index: -1;
    overflow: hidden;
    background: linear-gradient(to bottom, #780e0e, #180801);
  }
</style>

<script>
  import * as THREE from "three";

  var figureSize = 2;
  var mouseDown = false;

  const colors = {
    green: convertColor(0, 255, 0),
    red: convertColor(255, 0, 0),
    pink: convertColor(255, 177, 121),
    blue: convertColor(0, 0, 255),
    black: convertColor(0, 0, 0),
    white: convertColor(255, 255, 255),
  };

  function convertColor(red:number, green:number, blue:number) {
    return new THREE.Color(red/255, green/255, blue/255);
  }

  function getIcosahedron() {
    const geometry = new THREE.IcosahedronGeometry(figureSize, 0);

    const solidMaterial = new THREE.MeshBasicMaterial({
      color: colors.pink,
      transparent: true,
      opacity: 0.15,
      side: THREE.DoubleSide,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1,
    });

    const solidMesh = new THREE.Mesh(geometry, solidMaterial);

    const wireMaterial = new THREE.MeshBasicMaterial({
      color: colors.black,
      wireframe: true,
    });
    const wireMesh = new THREE.Mesh(geometry, wireMaterial);
    solidMesh.add(wireMesh);

    return solidMesh;
  }

  function init() {
    const container = document.getElementById("canvas-container");

    if (!container) {
      return;
    }

    const scene = new THREE.Scene();

    scene.fog = new THREE.Fog(colors.red, 4, 8);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Objects
    const icosahedron = getIcosahedron();
    scene.add(icosahedron);

    // Interaction State
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const mouse3D = new THREE.Vector3();

    // Physics State
    const originalPosition = new THREE.Vector3(0, 0, 0);
    const velocity = new THREE.Vector3(0, 0, 0);
    const repulsionRadius = 4;
    const repulsionStrength = 0.1;
    const springStrength = 0.05;
    const friction = 0.5;

    // Mouse Move Handler
    window.addEventListener("mousemove", (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // Camera Zoom Logic
    let targetZ = 5;
    const zoomSpeed = 0.08;

    document.addEventListener("mousedown", () => {
      mouseDown = true;
      // Zoom out
      targetZ = 7;
    });

    document.addEventListener("mouseup", () => {
      mouseDown = false;
      targetZ = 5;
    });

    // Add this inside the animate loop
    const updateCamera = () => {
      camera.position.z += (targetZ - camera.position.z) * zoomSpeed;
    };

    // Animation
    const animate = () => {
      requestAnimationFrame(animate);

      // 1. Calculate Mouse Position in 3D (z=0)
      raycaster.setFromCamera(mouse, camera);
      raycaster.ray.intersectPlane(plane, mouse3D);

      // 2. Physics Logic
      const distance = icosahedron.position.distanceTo(mouse3D);

      // Repulsion Force
      if (distance < repulsionRadius) {
        const repulsionDir = new THREE.Vector3()
          .subVectors(icosahedron.position, mouse3D)
          .normalize();
        const force = (1 - distance / repulsionRadius) * repulsionStrength;
        velocity.add(repulsionDir.multiplyScalar(force));
      }

      // Spring Force (Return to center)
      const springDir = new THREE.Vector3(
        figureSize,
        figureSize,
        figureSize
      ).subVectors(originalPosition, icosahedron.position);
      velocity.add(springDir.multiplyScalar(springStrength));

      // Apply Velocity & Friction
      velocity.multiplyScalar(friction);
      icosahedron.position.add(velocity);

      // Rotation (keep it spinning)
      icosahedron.rotation.x += 0.01;
      icosahedron.rotation.y += 0.01;

      // spin faster if mouse held
      if (mouseDown) {
        icosahedron.rotation.x += 0.02;
        icosahedron.rotation.y += 0.02;
      }

      renderer.render(scene, camera);
      updateCamera();
    };

    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  // Ensure DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
</script>
